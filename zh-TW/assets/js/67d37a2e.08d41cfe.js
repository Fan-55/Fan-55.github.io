"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[714],{1636:e=>{e.exports=JSON.parse('{"version":{"pluginId":"notes","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"notes":[{"type":"link","label":"README","href":"/zh-TW/notes/","docId":"readme","unlisted":false},{"type":"category","label":"C","items":[{"type":"link","label":"C style string","href":"/zh-TW/notes/C/C-style-string","docId":"C/C-style-string","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/zh-TW/notes/C"},{"type":"category","label":"Computer Architecture","items":[{"type":"link","label":"Big and Little Endian","href":"/zh-TW/notes/computer-architecture/big-and-little-endian","docId":"computer-architecture/big-and-little-endian","unlisted":false},{"type":"link","label":"Instruction Set Architecture","href":"/zh-TW/notes/computer-architecture/instruction-set-architecture","docId":"computer-architecture/instruction-set-architecture","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/zh-TW/notes/computer-architecture"},{"type":"category","label":"Data structures and Algorithms","items":[{"type":"link","label":"Asymptotic Notation","href":"/zh-TW/notes/dsa/asymptotic-notation","docId":"dsa/asymptotic-notation","unlisted":false},{"type":"link","label":"The Heap Data Structure","href":"/zh-TW/notes/dsa/heap","docId":"dsa/heap","unlisted":false},{"type":"category","label":"Sortings","items":[{"type":"link","label":"Insertion Sort","href":"/zh-TW/notes/dsa/sortings/insertion-sort","docId":"dsa/sortings/insertion-sort","unlisted":false},{"type":"link","label":"Selection Sort","href":"/zh-TW/notes/dsa/sortings/selection-sort","docId":"dsa/sortings/selection-sort","unlisted":false},{"type":"link","label":"Mergesort","href":"/zh-TW/notes/dsa/sortings/mergesort","docId":"dsa/sortings/mergesort","unlisted":false},{"type":"link","label":"Quicksort","href":"/zh-TW/notes/dsa/sortings/quicksort","docId":"dsa/sortings/quicksort","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","label":"Probability Review","href":"/zh-TW/notes/dsa/probability-review","docId":"dsa/probability-review","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/zh-TW/notes/dsa"}]},"docs":{"C/C-style-string":{"id":"C/C-style-string","title":"C-style string","description":"String literal/constant","sidebar":"notes"},"computer-architecture/big-and-little-endian":{"id":"computer-architecture/big-and-little-endian","title":"Big Endian and Little Endian","description":"Big endian computers use leftmost byte (i.e., most significant byte, MSB) as word address. Little endian computers use rightmost byte (i.e., least significant byte, LSB) as word address. Most computers are byte addressable, meaning each byte in memory has a unique address.","sidebar":"notes"},"computer-architecture/instruction-set-architecture":{"id":"computer-architecture/instruction-set-architecture","title":"Instruction Set Architecture","description":"Software communicates to hardware via a vocabulary. The words of the vocabulary (all the words that exist in a particular language) are called instructions, and the vocabulary itself is called the instruction set architecture, or simply architecture, of a computer.","sidebar":"notes"},"dsa/asymptotic-notation":{"id":"dsa/asymptotic-notation","title":"Asymptotic Notation","description":"Big-O Notation","sidebar":"notes"},"dsa/binary-search-tree":{"id":"dsa/binary-search-tree","title":"binary-search-tree","description":"Symbol Table"},"dsa/heap":{"id":"dsa/heap","title":"heap","description":"When fast maximum or minimum computations are required on a dynamically changing set of objects, the heap data structure may be the right choice. The heap can keep track of an evolving set of objects with keys and quickly identify the object with the maximum or minimum key.","sidebar":"notes"},"dsa/probability-review":{"id":"dsa/probability-review","title":"Probability Review","description":"1. Sample space","sidebar":"notes"},"dsa/sortings/insertion-sort":{"id":"dsa/sortings/insertion-sort","title":"Insertion Sort","description":"Insertion sort iterates the items and insert each item into the proper place among the items that are already sorted. In iteration $i$, exchange a[i] with each entry to the left of $i$ that is larger than a[i]. To check if the entry to the left of $i$ is larger than a[i], we need another index $j$ starting from $i$ to keep track of a[i] (a[i] is now pointed by a[j]) and the entry to the left of a[i] (i.e., a[j-1]). After a[i] exchanges with the larger entry, $j$ should decrease by $1$ so that $j$ still points to a[i].","sidebar":"notes"},"dsa/sortings/mergesort":{"id":"dsa/sortings/mergesort","title":"Mergesort","description":"Mergesort is a canonical divide-and-conquer algorithm in the divide-and-conquer algorithm design paradigm. The idea of divide-and-conquer algorithm design is to break the problem into smaller subproblems, solve subproblems recursively, and finally combine the solutions to the subproblems into one for the original problem.","sidebar":"notes"},"dsa/sortings/quicksort":{"id":"dsa/sortings/quicksort","title":"Quicksort","description":"1. Introduction","sidebar":"notes"},"dsa/sortings/selection-sort":{"id":"dsa/sortings/selection-sort","title":"Selection Sort","description":"First, find the smallest item in the array and exchange it with the first entry. If the first entry is the smallest, it should exchange itself. Then, find the next smallest item and exchange it with the second entry. Continue in this way until the whole array is sorted.","sidebar":"notes"},"readme":{"id":"readme","title":"README","description":"I just found this amazing tool to build a website for my notes.","sidebar":"notes"}}}}')}}]);