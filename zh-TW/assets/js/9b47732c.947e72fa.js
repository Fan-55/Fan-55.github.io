"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[746],{4444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=n(4848),o=n(8453);const s={},i="Binary Search Tree (BST)",l={id:"dsa/binary-search-tree",title:"binary-search-tree",description:"Symbol Table",source:"@site/notes/dsa/binary-search-tree.md",sourceDirName:"dsa",slug:"/dsa/binary-search-tree",permalink:"/zh-TW/notes/dsa/binary-search-tree",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},a={},c=[{value:"Symbol Table",id:"symbol-table",level:2},{value:"Binary Tree",id:"binary-tree",level:2},{value:"Binary Search Tree",id:"binary-search-tree",level:2},{value:"Performance",id:"performance",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Code Snippet",id:"code-snippet",level:3}];function u(e){const t={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{style:{textAlign:"justify"},children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"binary-search-tree-bst",children:"Binary Search Tree (BST)"})}),(0,r.jsx)(t.h2,{id:"symbol-table",children:"Symbol Table"}),(0,r.jsxs)(t.p,{children:["A symbol table is an abstract data type for key-value pairs that is characterized by two operations: ",(0,r.jsx)(t.code,{children:"insert"})," (put) a new pair into the table and ",(0,r.jsx)(t.code,{children:"search"})," for (get) the value associated with a given key. The ",(0,r.jsx)(t.strong,{children:"binary search tree"})," is one of the data structures that implement the symbol table ADT and supports efficient operations not just search and insert, but several other operations as well because the keys of a binary search tree is ordered."]}),(0,r.jsx)(t.h2,{id:"binary-tree",children:"Binary Tree"}),(0,r.jsx)(t.p,{children:"In a binary tree, each node is pointed to by one node called parent except the root that is not pointed to by any node. Each node in a binary tree has exactly two links (i.e., pointers): a left link and a right link. A link can either point to another node (its left or right child) or be null if there is no child on that side. Each link, if it points to a node, can be viewed as connecting to the root of a subtree. This means that every node in the tree, along with all its descendants, forms a smaller binary tree rooted at that node."}),(0,r.jsx)(t.p,{children:"For example,"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"       A\n     /   \\\n    B     C\n   / \\   / \\\n  D   E\n"})}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Node ",(0,r.jsx)(t.code,{children:"A"})," is the root of the tree."]}),"\n",(0,r.jsxs)(t.li,{children:["Node ",(0,r.jsx)(t.code,{children:"B"})," and ",(0,r.jsx)(t.code,{children:"C"})," are the left and right children of ",(0,r.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Node ",(0,r.jsx)(t.code,{children:"B"}),", ",(0,r.jsx)(t.code,{children:"D"}),", ",(0,r.jsx)(t.code,{children:"E"})," together or ",(0,r.jsx)(t.code,{children:"C"})," alone can be viewed as a subtree which is also a binary tree."]}),"\n",(0,r.jsxs)(t.li,{children:["Node ",(0,r.jsx)(t.code,{children:"C"})," has two null links."]}),"\n"]}),(0,r.jsx)(t.h2,{id:"binary-search-tree",children:"Binary Search Tree"}),(0,r.jsx)(t.p,{children:"A binary search tree  is a binary tree where each node has a key associated to a value and satisfies the restriction that the key of any node is larger than all the keys of its left subtree and smaller than all the keys of its right subtree."}),(0,r.jsx)(t.p,{children:"For example,"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"          S\n       /     \\\n     E        X\n   /   \\    /   \\\n  A     R\n / \\   / \\\n    C  H\n   / \\/ \\\n"})})]}),"\n",(0,r.jsx)(t.h2,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(t.p,{children:["Because all the methods go down one or two paths of the tree, all the operations of binary search tree take time proportional to the height of the tree in the worst case ",(0,r.jsxs)(t.span,{className:"katex",children:[(0,r.jsx)(t.span,{className:"katex-mathml",children:(0,r.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(t.semantics,{children:[(0,r.jsxs)(t.mrow,{children:[(0,r.jsx)(t.mi,{mathvariant:"normal",children:"O"}),(0,r.jsx)(t.mo,{stretchy:"false",children:"("}),(0,r.jsx)(t.mtext,{children:"tree\xa0height"}),(0,r.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,r.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\Omicron(\\text{tree height})"})]})})}),(0,r.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(t.span,{className:"base",children:[(0,r.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(t.span,{className:"mord mathrm",children:"O"}),(0,r.jsx)(t.span,{className:"mopen",children:"("}),(0,r.jsx)(t.span,{className:"mord text",children:(0,r.jsx)(t.span,{className:"mord",children:"tree\xa0height"})}),(0,r.jsx)(t.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(t.h3,{id:"code-snippet",children:"Code Snippet"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://github.com/Fan-55/Algorithms/blob/main/src/BinarySearchTree.java",children:"BST Code snippet"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",metastring:'title="java"',children:"import edu.princeton.cs.algs4.StdOut;\n\npublic class BinarySearchTree <Key extends Comparable<Key>, Value>{\n\n  private Node root;\n\n  private class Node {\n    private Key key;\n    private Value val;\n    private Node left;\n    private Node right;\n    private int N; // # of nodes in the subtree rooted here\n\n    public Node(Key key, Value val, int N) {\n      this.key = key;\n      this.val = val;\n      this.N = N;\n    }\n  }\n\n  public int size() {\n    return size(root);\n  }\n\n  private int size (Node node) {\n    return node == null ? 0 : node.N;\n  }\n\n  public Value get(Key searchKey) {\n    return get(root, searchKey);\n  }\n\n  private Value get(Node subtreeRoot, Key searchKey) {\n    if (subtreeRoot == null) return null;\n    int cmp = searchKey.compareTo(subtreeRoot.key);\n    if (cmp < 0) {\n      return get(subtreeRoot.left, searchKey);\n    } else if (cmp > 0) {\n      return get(subtreeRoot.right, searchKey);\n    } else {\n      return subtreeRoot.val;\n    }\n  }\n\n\n  public void put(Key key, Value val) {\n    root =  put(root, key, val);\n  }\n\n  private Node put(Node subtreeRoot, Key key, Value val) {\n    if (subtreeRoot == null) return new Node(key, val, 1);\n    int cmp = key.compareTo(subtreeRoot.key);\n    if (cmp < 0) {\n      subtreeRoot.left = put(subtreeRoot.left, key, val);\n    } else if (cmp > 0) {\n      subtreeRoot.right = put(subtreeRoot.right, key, val);\n    } else {\n      subtreeRoot.val = val;\n    }\n    subtreeRoot.N = 1 + size(subtreeRoot.left) + size(subtreeRoot.right);\n    return subtreeRoot;\n  }\n\n  public Key min() {\n    return min(root).key;\n  }\n\n  private Node min(Node subtreeRoot) {\n    if (subtreeRoot.left == null) return subtreeRoot;\n    return min(subtreeRoot.left);\n  }\n\n  public Key max() {\n    return max(root).key;\n  }\n\n  private Node max(Node subtreeRoot) {\n    if (subtreeRoot.right == null) return subtreeRoot;\n    return max(subtreeRoot.right);\n  }\n\n  public Key floor(Key key) {\n    return floor(root, key).key;\n  }\n\n  private Node floor(Node subtreeRoot, Key key) {\n    if (subtreeRoot == null) return null;\n    int cmp = key.compareTo(subtreeRoot.key);\n    if (cmp < 0) {\n      return floor(subtreeRoot.left, key);\n    } else if (cmp == 0) {\n      return subtreeRoot;\n    }\n    Node floorNode = floor(subtreeRoot.right, key);\n    return floorNode == null ? subtreeRoot: floorNode;\n  }\n\n  public Key ceiling(Key key) {\n    return ceiling(root, key).key;\n  }\n\n  private Node ceiling(Node subtreeRoot, Key key) {\n    if (subtreeRoot == null) return null;\n    int cmp = key.compareTo(subtreeRoot.key);\n    if (cmp > 0) {\n      return ceiling(subtreeRoot.right, key);\n    } else if (cmp == 0) {\n      return subtreeRoot;\n    }\n    Node ceilingNode = ceiling(subtreeRoot.left, key);\n    return ceilingNode == null ? subtreeRoot: ceilingNode;\n  }\n\n  public Key select(int k) {\n    return select(root,k).key;\n  }\n\n  private Node select(Node subtreeRoot, int k) {\n    if (subtreeRoot == null) return null;\n    int leftSubtreeSize = size(subtreeRoot.left);\n    if (leftSubtreeSize == k) {\n      return subtreeRoot;\n    } else if (leftSubtreeSize > k) {\n      return select(subtreeRoot.left, k);\n    } else {\n      return select(subtreeRoot.right, k-leftSubtreeSize-1);\n    }\n  }\n\n  public int rank(Key key) {\n    return rank(root, key);\n  }\n\n  private int rank(Node subtreeRoot, Key key) {\n    if (subtreeRoot == null) return 0;\n    int cmp = key.compareTo(subtreeRoot.key);\n    if (cmp == 0) {\n      return size(subtreeRoot.left);\n    } else if (cmp < 0) {\n      return  rank(subtreeRoot.left, key);\n    } else {\n      return size(subtreeRoot.left) + 1 + rank(subtreeRoot.right, key) ;\n    }\n  }\n\n  public void deleteMin() {\n    root = deleteMin(root);\n  }\n\n  private Node deleteMin(Node subtreeRoot) {\n    if (subtreeRoot.left == null) {\n      return subtreeRoot.right;\n    };\n    subtreeRoot.left = deleteMin((subtreeRoot.left));\n    subtreeRoot.N = size(subtreeRoot.left) + size(subtreeRoot.right) + 1;\n    return subtreeRoot;\n  }\n\n  public void delete(Key key) {\n    root = delete(root, key);\n  }\n\n  private Node delete(Node subtreeRoot, Key key) {\n    if (subtreeRoot == null) {\n      return null;\n    }\n    int cmp = key.compareTo(subtreeRoot.key);\n    if (cmp < 0) {\n      subtreeRoot.left =  delete(subtreeRoot.left, key);\n    } else if (cmp > 0) {\n      subtreeRoot.right = delete(subtreeRoot.right, key);\n    } else {\n      if (subtreeRoot.left == null) {\n        return subtreeRoot.right;\n      } else if (subtreeRoot.right == null) {\n        return subtreeRoot.left;\n      } else {\n        Node temp = subtreeRoot;\n        subtreeRoot = min(subtreeRoot.right);\n        subtreeRoot.right = deleteMin(temp.right);\n        subtreeRoot.left = temp.left;\n      }\n    }\n    subtreeRoot.N = size(subtreeRoot.right) + size(subtreeRoot.left) + 1;\n    return subtreeRoot;\n  }\n\n  private void print(Node subtreeRoot) {\n    if (subtreeRoot == null) return;\n    print(subtreeRoot.left);\n    StdOut.println(subtreeRoot.key);\n    print(subtreeRoot.right);\n  }\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var r=n(6540);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);